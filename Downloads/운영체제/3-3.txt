// 7분 36초까지 복습
// 오늘부터는 프로세스간 협력을 배울거임
- 프로세스들 간에 협력한다는 얘기는 프로세스간 통신한다는 얘기
- 즉, 데이터를 주고받음
- 프로세스 간에 데이터를 어떻게 주고받는지에 방법이 크게 2가지가 있음
	- message passing
	- shared memory
// 8분 31초 : 칠판에 그림그려주시는 거 같은데 볼 수가 없어서 궁금함,,,
- A라는 프로세스가 B라는 프로세스한테 데이터를 전달하고 싶음
- A라는 프로세스가 B라는 프로세스의 영역에 직접 write를 하는 건 불가능 -> why? : memory protection -> 즉, 프로세스는 자기한테 허용된 공간(=메모리주소)만 access할 수 있지, 다른 영역을 access하면 안 됨. -> 만약 A라는 프로세스가 B라는 프로세스에 access가 가능하다고 하면 A가 B를 죽일 수도 있는 거임
- 즉, A가 직접 B에 access하지 못하니까, OS의 도움을 받아야 함
- OS에 예를 들어, 큐를 만들고, A가 data를 OS의 큐에 전달하면, 큐를 통해 B로 data전달
- 프로세스 -> 메시지를 커널로 전달 -> 프로세스 : message passing
- A와 B가 동시에 access할 수 있는, A와 B가 아닌 다른 공간에, shared memory를 만들고 -> A가 shared memory에 data를 쓰고, B가 data를 읽어가는 형태 : shared memory

- message mailbox : message를 하나만 보관
- message queue : message를 여러개 보관

- message passing의 장점 : A와 B의 동기를 맞춰주는 일을 OS가 알아서 해줌
	- ex) A가 메시지를 보내놨으면 그걸 그냥 B가 가져가면 되고
	A가 아직 메시지를 안 보내놨으면 B가 기다렸다가(waiting)
	A가 메시지를 보내면 B의 상태가 ready가 되고 스케쥴된다면 수행됨
- message passing의 단점 : 메시지가 message mailbox나 message queue에 복사가 되고, 다시 프로세서B로 복사가 됨 -> 성능상의 오버헤드 발생

// shared memory의 장단점은 message passing의 장단점 거꾸로!
// shared memory는 처음에 만들 때는 OS가 만들어줘야 하는데 그 이후로 동작할 때는 OS의 도움없이 알아서 동작
- shared memory의 장점 : shared memory에서 직접 데이터를 쓰고 읽으면 되니까 -> copy를 해야하는 오버헤드는 발생하지 않음 -> data가 크면 클수록 message passing에 비해 성능이 좋음
- shared memory의 단점 : 동기화(synchronization)을 OS가 해주지 않고 프로세스A,B가 직접해야함 

41pg) 
- Direct communication (쉽게 말해, process를 지정하는 것)
: message를 전달할 때 message를 수신하는 process를 지정해서 보내는 것
- Indirect communication (쉽게 말해, mailbox를 지정하는 것)
: message를 받을 process가 누구다라고 지정하는 게 아니라, message를 어느 mailbox에 넣어라라고 지정하는 것 -> A라는 process가 hello라는 mailbox에 message를 넣을테니까 B도 hello라는 mailbox에서 message를 가져가라고 약속하는 것
// cf) 현재 대부분의 OS는 direct communication을 구현하지 않고, indirect communication을 지원을 함

44pg)
- synchronization을 구현을 할 때
- A가 message queue에 data를 집어넣을테니, B가 가져가라고 OS에서 도와줌
- "A가 아직 안 넣었어, 그럼 B는 waiting상태로 기다리다가 -> A에서 message도착하면 -> B는 ready상태로 깨어남" => Blocking, Synchronous라고 함 // 26분 16초
- message queue에 data가 안 왔어 -> 그럼 B가 그냥 기다리는 게 아니라 다른 일을 하는 거야 -> 다른 일을 하다가 다시 왔나 안 왔나 보는 거 -> 이게 일종의 polling이라는 방식 -> 이런 건 non-blocking, asynchronous // 27분 14초이고 이해안됨
	- 통신에서, "폴링"은 한 프로그램이나 장치에서 다른 프로그램이나 장치들이 어떤 상태에 있는지를 지속적으로 체크하는 전송제어 방식 (구글링함)
- 지금 대부분의 OS가 message passing기술을 구현했을 때, default가 blocking, synchronous 방식임 -> 왜? OS가 다 해주니까 편해서

//~지금 message passing이라고 하는 IPC(InterProcess Communication)에서의 kernel이 지원해주는 issue들을 이야기 하고 있는거임
	- direct communication vs indirect communication
	- blocking vs nonblocking
	- buffering

45pg)
- message queue를 했을 떄, A가 data를 넣고 아직 B가 data를 가져가지 않았을 때, 커널에서 이 data를 임시로 가지고 있어야 함 -> 이렇게 data를 임시로 보관하는 공간을 buffer라고 함
- 임시적으로 data를 보관하는 행위 : buffering
- kernel에서 IPC를 위해서 data를 임시적으로 저장하는데 있어서 어떤 방법을 취할 수 있느냐 -> 3가지
	- Zero capacity : Buffering을 안 함 -> 즉, 누군가가 이거를 기다리고 있어 -> 보관하지 않고 바로 writing해줌 // if) 기다리지 않는다면 이 데이터는 버리겠다
	- Bounded capacity : 일정 공간을 buffer로 잡아두고 -> 예를 들어 10개정도 보낸 거 정도는 보관하는데 11개면 넘치니까 1개는 버리는 거
	- Unbounded capacity : 무한히 저장, 다 저장해줌 -> 이론적으로만 가능하고 -> 실제로는 커널에서 이걸 다 가지고 있다가는 메모리가 부족하니까 현실적으로는 안됨
	// 이 3가지 방법 중 OS가 선택하는 방식은 2번, Bounded capacity임

// message passing에 direct communication, indirect communication이 있고
// direct communication에 synchornous(blocking), asynchronous (nonblocking)있고
// message passing에서 buffering을 zero capacity로 하느냐, bounded capacity로 하느냐, unbounded로 하느냐
// ppt 말고 원서로 큰 그림 잡을 것

45pg)
// 지금까지는 IPC(InterProcess Communication)을 다룸
// IPC라고 하면, 하나의 컴퓨터에서(하나의 OS에서) 여러개의 process가 있는데 서로 통신하는 걸 -> IPC라고 함
// 그럼 이제는 2대의 컴퓨터가 network로 연결되어 있고, 각각의 컴퓨터의 process(1대에 1개의 process -> 2대니까 2개의 process)간 data를 주고받는 것도 process간 통신임
// 즉, process간 통신
	- 하나의 컴퓨터, 즉 하나의 운영체제 안에서 process간 통신하는건지
	- 다른 컴퓨터간 process끼리 통신하는건지
		- Sockets : TCP/IP 계열의 network에서 두 개의 프로세스간에 통신하기 위해서 만든 방법 (가장 널리 쓰임)
		- Remote Procedure Calls(=RPC) : 어떤 함수의 호출을 다른 컴퓨터에서 수행하고 그 결과를 돌려받는 것 (procedure하고 function하고 같다고 이해하면 됨)
		- Remote Method Invocation(=RMI) (Java) : Java class내에 있는 member와 memberfunction(=method) invocation
		// RPC랑 RMI랑 개념은 같은데
		RPC는 C에서 쓰이는 거고, RMI는 Java에서 쓰이는 거임

47pg)
- 소캣프로그래밍 많이 들어봤지? 모르면 알아서 찾아봐서 따라오래,,, ㅎㅎ,,,
(소캣프로그래밍 하려면 TCP/IP 알아야 한대)

48pg)
- 소캣프로그래밍을 하기 위해서는 2가지 주소가 필요한데
	- IP주소와 port number라는 주소가 필요함
- TCP/IP에서는 OSI 5 Layer만 얘기함
- network layer가 하는 일은 : end-to-end(Node간 통신) -> 주소가 필요함 -> network layer에서 주소는 IP address -> end-to-end node까지 패킷이 도착했어 -> 그럼 이 패킷을 누구한테 줘야함? -> 여러개의 process중 하나의 process에 이 패킷이 가야 함 -> 이거를 담당하는 layer는 transport layer임 -> 그래서 transport layer에서도 주소가 필요함 -> 어떤 프로세스가 받아야 하는지 -> 이 때 transport layer에서의 주소를 port라고 함
// IP : network layer에서의 주소
// port : transport layer에서의 주소
// IP, port 두 개를 합친 걸 socket address라고 함
// 통신을 할 때 패킷을 만들고 -> 이 패킷을 어떤 애한테 줘야겠다고 할 때 명시하는 주소가 socket address : network layer의 IP address와 transport layer의 TCP port number, UDP port number라고 함